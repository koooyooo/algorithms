> Lomuto分割は理解してきた気がします。「Hoare」分割に関して教えて下さい。

いいですね！✨
Lomuto が分かってきたところで、もう一方の **Hoare（ホーア）分割法** を押さえると「なぜ実装に差があるのか」がよく見えてきます。

---

## 🔹 Hoare 分割法とは

* **クイックソートの元祖**（発明者 Tony Hoare 氏の名前から）
* 基本戦略は「左右からスキャンして入れ替え」
* Lomuto と違って **pivot を末尾に退避しない**
* 通常は「配列の先頭」を pivot に使うことが多い

---

## 🔹 擬似コード（Hoare）

```
function partition(A, lo, hi):
    pivot = A[lo]
    i = lo - 1
    j = hi + 1
    while true:
        repeat:
            i = i + 1
        until A[i] >= pivot

        repeat:
            j = j - 1
        until A[j] <= pivot

        if i >= j:
            return j   # pivotの位置（または分割点）

        swap A[i] and A[j]
```

* `i` は左から右へ進んで「pivot 以上」を探す
* `j` は右から左へ進んで「pivot 以下」を探す
* 見つけたら swap
* 交差したら終了 → `j` が分割境界

---

## 🔹 具体例

配列 `[3, 8, 2, 5, 1, 4, 7, 6]`, pivot = 3

1. i=0, j=8
2. iを進める → `A[0]=3 >= 3` → stop（i=0）
3. jを戻す → `A[7]=6 >3` → j=6, j=5(=7>3), j=4(=1<=3 stop)
   → i=0, j=4
4. i\<j なので swap A\[0]=3, A\[4]=1 → `[1,8,2,5,3,4,7,6]`
5. 続けて i=1 から … j=3 まで … → swap …
6. 最終的に pivot 未満が左、pivot 以上が右に分かれる

---

## 🔹 Lomuto と Hoare の違い

| 特徴          | Lomuto         | Hoare                       |
| ----------- | -------------- | --------------------------- |
| 実装の単純さ      | 簡単、直感的         | やや複雑（2本ポインタを動かす）            |
| pivotの選び方   | 末尾に退避することが多い   | 先頭に置いたまま使うことが多い             |
| swap回数      | 多い             | 少ない（効率的）                    |
| 安定性（重複多い場合） | 分割効率が悪化することもある | 3分割に近い挙動で効率が落ちにくい           |
| 戻り値         | pivot の確定位置    | 左右の分割境界（pivotがそこに収まるとは限らない） |

---

## 🔹 どちらを使うべき？

* 教科書や学習用 → **Lomuto**（理解しやすい）
* 実用の高速実装 → **Hoare** か **Dutch National Flag（3分割法）**

---

👉 ここで確認です：

* Lomuto は「末尾 pivot 退避 → 1本ループで小さいのを前に寄せる」
* Hoare は「両端からスキャン → 大小が見つかれば swap → 交差したら終わり」

このイメージを持った上で、次は小さい配列（例 `[4, 2, 7, 1]`）を **Hoare分割で実際に手計算トレース**してみましょうか？
